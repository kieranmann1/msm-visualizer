---
title: "MITO Results"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```{r global, include=FALSE}
library(flexdashboard)

library(shinythemes)
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)
library(readr)
library(DT)
library(tmap)
library(leaflet)
library(RColorBrewer)
library(sf)


### PRELIMINARY SETUP

##READ IN ZONES SHAPEFILE
zones <- st_read("map/zonesNew.shp")


## DEFINE VARIABLES TO USE
myModeNames <- c("Car Driver", "Car Passenger", "Bicycle", "Bus", "Train", 
                 "Tram/Metro", "Walk", "Private AV", "Shared AV")
myModeCodes <- c("autoDriver", "autoPassenger", "bicycle", "bus", "train", 
                 "tramOrMetro", "walk", "privateAV", "sharedAV")
myYLabels <- c("Number of Persons", "Number of Households", "Frequency", "Frequency", "Mode Share")
myXLabels <- c("Number of Trips", "Number of Trips", "Travel Distance (km)", "Travel Time (minutes)", "Mode")
myAspatial <- c("Persons by Number of Trips", "Households by Number of Trips", "Travel Distance Distribution",
                   "Travel Time Distribution", "Mode Share")
myAspatialCodes <- c("PPbyTrips", "HHbyTrips", "Distance", "Time", "ModeShare")
mySpatial <- c("Produced Trips per sq.km", "Attracted Trips per sq.km", "Average Travel Time Budget (Minutes)", 
               "Average Distance Travelled (Km)", "Average Time Travelled (Minutes)")
mySpatialCodes <- c("P", "A", "TTB", "AvDist", "AvTime")
myPurposeNames <- c("Home-based Work", "Home-based Education", "Home-based Shopping", "Home-based Other",
                    "Non-home-based Work", "Non-home-based Other")
myPurposeCodes <- c("HBW", "HBE", "HBS", "HBO", "NHBW", "NHBO")
mySpatialStyles <- c("quantile", "quantile", "pretty", "pretty", "pretty")


## ASSIGN INITIAL NAMES TO VECTORS
names(myAspatialCodes) <- myAspatial
names(mySpatialCodes) <- mySpatial
names(myPurposeCodes) <- myPurposeNames


## DEFINE FUNCTION THAT RETURNS THE NAME OF THE SELECTED VARIABLE CODE
myNaming <- function(myNames, myCodes, mySelect){
  names(myCodes) <- myNames
  return (names(myCodes[myCodes == mySelect]))
}
```

Column {.sidebar data-width=300}
-----------------------------------------------------------------------
### User Input

```{r}
# CREATE INPUTS FOR UPLOADING FILES
wellPanel(
  fileInput(inputId = "resultFiles",
            label = "Upload result files", 
            multiple = TRUE,
            accept = ".csv"),
  checkboxInput(inputId = "scenario",
                label = "Compare scenarios", 
                value = FALSE),
  conditionalPanel("input.scenario == true",
                    fileInput(inputId = "scenarioFiles", 
                              label = "Upload comparison files",
                              multiple = TRUE,
                              accept = ".csv"))
)

# CREATE BUTTONS/INPUTS FOR SELECTING DATA TYPE AND TRIP PURPOSE
wellPanel(
  radioButtons(inputId = "dataType", 
               label = "Select type of data", 
               choices = c("Aspatial", "Spatial"), 
               inline = TRUE),
  br(),
  selectInput(inputId = "purpose", 
              label = "Select trip purpose",
              choices = myPurposeCodes,
              selected = "HBW")
)
      
wellPanel(

  # DEFINE WHAT SHOULD BE DISPLAYED WHEN ASPATIAL DATA IS SELECTED
  conditionalPanel("input.dataType == 'Aspatial'",
                    selectInput(inputId = "aspatialData",
                                label = "Selece aspatial attribute",
                                choices = myAspatialCodes,
                                selected = "ModeShare"),
                    br(),
                    checkboxInput(inputId = "absRel",
                                  label = "View as percentage",
                                  value = FALSE)),
  # DEFINE WHAT SHOULD BE DISPLAYED WHEN SPATIAL DATA IS SELECTED
  conditionalPanel("input.dataType == 'Spatial'",
                    selectInput(inputId = "spatialData",
                                label = "Select spatial attribute",
                                choices = mySpatialCodes,
                                selected = "P"),
                    br(),
                    sliderInput(inputId = "categories",
                                label = "Select number of categories", 
                                value = 5, min = 3, max = 10, step = 1),
                    checkboxInput(inputId = "manualStyle",
                                  label = "Define breakpoints", 
                                  value = FALSE)),
  conditionalPanel("input.dataType == 'Spatial' && input.manualStyle == true",
                    textInput(inputId = "breaks", 
                              label = "Enter breakpoints (no space)",
                              value = "-Inf,-100,0,100,Inf",
                              placeholder = "-Inf,-100,0,100,Inf"))
)

```

Column {data-width=900 .tabset}
-----------------------------------------------------------------------

```{r}

 ## DEFINING LOGIC FOR ASPATIAL DATA
  # CREATE A REACTIVE THAT HOLDS THE CLEANED ASPATIAL DATA
  clean_aspatial <- reactive({
    req(input$resultFiles)
    myFiles <- input$resultFiles %>% 
      arrange(size)
    link <- myFiles$datapath[1] 
    link %>% 
      read_csv() %>% 
      separate(Attribute, into = c("Feature", "Alternatives"), sep = "_") %>% 
      mutate_at(vars(HBW:NHBO), funs(as.numeric)) %>% 
      mutate_at(vars(HBW:NHBO), funs(replace_na), replace = 0) %>% 
      group_by(Feature) %>%
      mutate_at(vars(HBW:NHBO), funs(s = 100 * . / sum(.))) %>% 
      ungroup() %>% 
      mutate_at(vars(HBW_s:NHBO_s), funs(replace_na), replace = 0) %>% 
      mutate_at(vars(HBW_s:NHBO_s), funs(round), digits = 2)
  })
  
  # CREATE A REACTIVE THAT HOLDS THE CLEANED ASPATIAL DATA OF THE COMPARISON SCENARIO
  clean_aspatial2 <- reactive({
    req(input$scenarioFiles)
    myFiles <- input$scenarioFiles %>% 
      arrange(size)
    link <- myFiles$datapath[1] 
    link %>% 
      read_csv() %>% 
      separate(Attribute, into = c("Feature", "Alternatives"), sep = "_") %>% 
      mutate_at(vars(HBW:NHBO), funs(as.numeric)) %>% 
      mutate_at(vars(HBW:NHBO), funs(replace_na), replace = 0) %>% 
      group_by(Feature) %>%
      mutate_at(vars(HBW:NHBO), funs(s = 100 * . / sum(.))) %>% 
      ungroup() %>% 
      mutate_at(vars(HBW_s:NHBO_s), funs(replace_na), replace = 0) %>% 
      mutate_at(vars(HBW_s:NHBO_s), funs(round), digits = 2)
  })
  
  # CREATE A REACTIVE THAT HOLDS THE SELECTED ASPATIAL ATTRIBUTE TO BE DISPLAYED
  plot_subset <- reactive({
    attribute <- myNaming(myXLabels, myAspatialCodes, input$aspatialData)
    absVal <- myNaming(myYLabels, myAspatialCodes, input$aspatialData)
    relVal <- paste(absVal, " (%)")
    df <- clean_aspatial() %>% 
      filter(Feature == input$aspatialData) %>%
      select(Alternatives, input$purpose, paste(input$purpose, "_s", sep = ""))
    if(input$aspatialData != "ModeShare"){
      df <- mutate(df, Alternatives = as.numeric(Alternatives))
    } else {
      df <- mutate(df, Alternatives = mapvalues(Alternatives, from = myModeCodes, 
                                                to = myModeNames, warn_missing = FALSE))
    }
    names(df)[1:3] <- c(attribute, absVal, relVal)
    df
  })
  
  # CREATE A REACTIVE THAT HOLDS THE SELECTED ASPATIAL ATTRIBUTE FROM BOTH SCENARIOS
  plot_subset2 <- reactive({
    attribute <- myNaming(myXLabels, myAspatialCodes, input$aspatialData)
    absVal <- myNaming(myYLabels, myAspatialCodes, input$aspatialData)
    relVal <- paste(absVal, " (%)")
    df <- clean_aspatial2() %>% 
      filter(Feature == input$aspatialData) %>%
      select(Alternatives, input$purpose, paste(input$purpose, "_s", sep = ""))
    if(input$aspatialData != "ModeShare"){
      df <- mutate(df, Alternatives = as.numeric(Alternatives))
    } else {
      df <- mutate(df, Alternatives = mapvalues(Alternatives, from = myModeCodes, 
                                                to = myModeNames, warn_missing = FALSE))
    }
    names(df)[1:3] <- c(attribute, absVal, relVal)
    df <- left_join(plot_subset(), df, by = attribute, suffix = c(" (Base)", " (Comparison)")) %>% 
      mutate(Difference = .[[4]] - .[[2]], `Difference (%)` = round(.[[5]] - .[[3]], digits = 2))
    df
  })
  
  # CREATE A TABLE THAT CONTAINS THE PLOTTED ASPATIAL DATA
  output$plotTable <- DT::renderDataTable({
    if (input$scenario == FALSE){
      df <- plot_subset()
    } else {
      df <- plot_subset2()
    }
    DT::datatable(df, rownames = FALSE, extensions = "Buttons", 
                  options = list(pageLength = 15, dom = "Bfrtip", buttons = c("copy", "csv", "print")))
  })
  
  # CREATE A CHART THAT DISPLAYS THE ASPATIAL ATTRIBUTES
  output$charts <- renderPlotly({
    if (input$scenario == FALSE){
      df <- plot_subset()
    } else {
      df <- plot_subset2() %>% 
        select(1, 6, 7)
    }
    realNames <- colnames(df)      
    colnames(df) <- c("myAttr", "myAbs", "myRel")    
    if(input$aspatialData == "ModeShare" & input$scenario == FALSE){
      plot_ly(df, labels = ~myAttr, values = ~myRel, type = 'pie', sort = FALSE, 
              marker = list(colors = brewer.pal(9, "Pastel1"))) %>% 
        layout(showlegend = T)
    } else{
      if (input$absRel == FALSE){
        df <- mutate(df, myColor = ifelse(myAbs < 0, "#fbb4ae", "#b3cde3"))
        plot_ly(df, y = ~myAbs, x = ~myAttr, type = "bar", mode = "markers", color = ~I(myColor)) %>% 
          layout(yaxis = list(title = realNames[2]),
                 xaxis = list(title = realNames[1]))      
      } else {
        df <- mutate(df, myColor = ifelse(myRel < 0, "#fbb4ae", "#b3cde3"))
        plot_ly(df, y = ~myRel, x = ~myAttr, type = "bar", mode = "markers", color = ~I(myColor)) %>% 
          layout(yaxis = list(title = realNames[3]),
                 xaxis = list(title = realNames[1]))
      }      
    }
  })
  
  
  ## DEFINING LOGIC FOR SPATIAL DATA
  # CREATE A REACTIVE THAT HOLDS THE CLEANED SPATIAL DATA
  clean_spatial <- reactive({
    req(input$resultFiles)
    myFiles <- input$resultFiles %>% 
      arrange(size)
    if(nrow(myFiles) > 1){
      link <- myFiles$datapath[2]
    } else {
      link <- myFiles$datapath[1]
    }
    link %>%  
      read_csv() %>% 
      inner_join(zones, by = c("Zone" = "id")) %>%
      mutate(AllP = sum(c(HBWA, HBEA, HBSA, HBOA, NHBWA, NHBOA)),
             AllA = sum(c(HBWA, HBEA, HBSA, HBOA, NHBWA, NHBOA))) %>% 
      mutate_at(paste0(myPurposeCodes, "P"), funs(1000000 * . / Area)) %>% 
      mutate_at(paste0(myPurposeCodes, "A"), funs(1000000 * . / Area)) %>% 
      mutate_at(paste0(myPurposeCodes, "P"), funs(round)) %>% 
      mutate_at(paste0(myPurposeCodes, "A"), funs(round)) %>% 
      st_sf()
  })
  
  # CREATE A REACTIVE THAT HOLDS THE CLEANED SPATIAL DATA OF THE COMPARISON SCENARIO
  clean_spatial2 <- reactive({
    req(input$scenarioFiles)
    myFiles <- input$scenarioFiles %>% 
      arrange(size)
    if(nrow(myFiles) > 1){
      link <- myFiles$datapath[2]
    } else {
      link <- myFiles$datapath[1]
    }
    link %>%  
      read_csv() %>% 
      inner_join(zones, by = c("Zone" = "id")) %>%
      mutate(AllP = sum(c(HBWA, HBEA, HBSA, HBOA, NHBWA, NHBOA)),
             AllA = sum(c(HBWA, HBEA, HBSA, HBOA, NHBWA, NHBOA))) %>% 
      mutate_at(paste0(myPurposeCodes, "P"), funs(1000000 * . / Area)) %>% 
      mutate_at(paste0(myPurposeCodes, "A"), funs(1000000 * . / Area)) %>% 
      mutate_at(paste0(myPurposeCodes, "P"), funs(round)) %>% 
      mutate_at(paste0(myPurposeCodes, "A"), funs(round)) %>% 
      st_sf()
  })
  
  # CREATE A REACTIVE THAT HOLDS THE SELECTED SPATIAL ATTRIBUTE TO BE DISPLAYED
  map_subset <- reactive({
    attribute <- paste0(input$purpose, input$spatialData)
    df <- clean_spatial() %>% 
      select(Zone, attribute, geometry)
    df[[2]] = round(df[[2]], digits = 2)
    df
  })
  
  # CREATE A REACTIVE THAT HOLDS THE SELECTED SPATIAL ATTRIBUTE FROM BOTH SCENARIOS
  map_subset2 <- reactive({
    attribute <- paste0(input$purpose, input$spatialData)
    df <- clean_spatial2() %>% 
      st_set_geometry(NULL) %>% 
      select(Zone, attribute) 
    df[[2]] = round(df[[2]], digits = 2)
    df <- left_join(map_subset(), df, by = "Zone") %>% 
      mutate(Difference = .[[3]] - .[[2]])
    df
  })
  
  # CREATE A TABLE THAT CONTAINS THE PLOTTED SPATIAL DATA
  output$mapTable <- DT::renderDataTable({
    myAttribute <- myNaming(mySpatial, mySpatialCodes, input$spatialData)
    if (input$scenario == FALSE){
      df <- map_subset() 
      names(df)[2] <- myAttribute
    } else {
      df <- map_subset2()
      names(df)[2] <- paste(myAttribute, " (Base)")
      names(df)[3] <- paste(myAttribute, " (Comparison)")
    }
    df <- df %>%
      st_set_geometry(NULL)
    DT::datatable(df, rownames = FALSE, extensions = "Buttons", 
                  options = list(pageLength = 15, dom = "Bfrtip", buttons = c("copy", "csv", "print")))
  })
  
  # CREATE A MAP THAT DISPLAYS SPATIAL ATTRIBUTES
  output$map <- renderLeaflet({
    if (input$scenario == FALSE) {
      df <- map_subset()
      myAttribute <- names(df)[2]
    } else {
      df <- map_subset2()
      myAttribute <- names(df)[4]
    }
    if(input$manualStyle == FALSE){
      myStyle <- myNaming(mySpatialStyles, mySpatialCodes, input$spatialData)
      myBreak <- NULL
    } else {
      myStyle <- "fixed"
      myBreak <- as.numeric(unlist(strsplit(input$breaks, ",")))
    }
    tmap_leaflet(tm_shape(df) +
                   tm_fill(myAttribute,
                           title = myNaming(mySpatial, mySpatialCodes, input$spatialData),
                           style = myStyle, breaks = myBreak, n = input$categories))
  })
  
  # CREATE A CAPTION FOR THE DISPLAYED DATA
  output$caption <- renderText({
    if(input$dataType == "Aspatial"){
      paste(myNaming(myAspatial, myAspatialCodes, input$aspatialData), " for ",
            myNaming(myPurposeNames, myPurposeCodes, input$purpose), " Trips")
    } else if(input$dataType == "Spatial"){
      paste(myNaming(mySpatial, mySpatialCodes, input$spatialData), " for ",
            myNaming(myPurposeNames, myPurposeCodes, input$purpose), " Trips")
    }
  })
  

 ## PANEL TO DISPLAY OUTPUTS
 fillCol( height = 600, flex = c(NA, 1),
     h4(textOutput("caption")),
      conditionalPanel("input.dataType == 'Aspatial'",
                       tabsetPanel(type = "tabs",
                                   tabPanel("Figure",
                                            plotlyOutput("charts", height = "800px")),
                                   tabPanel("Data",
                                            br(),
                                            DT::dataTableOutput("plotTable")))),
      conditionalPanel("input.dataType == 'Spatial'",
                       tabsetPanel(type = "tabs",
                                   tabPanel("Figure",
                                            leafletOutput("map", height = "800px")),
                                   tabPanel("Data",
                                            br(),
                                            DT::dataTableOutput("mapTable"))))
)
```